#include <opencv2/core.hpp>
#include "BallDetector.h"

cv::Vec3b BallDetector::fieldMeanColor(const cv::Mat& image, int kernel_size)const{

    int x = image.size().width/2; /*defines the coordinates of the center of the image*/
    int y = image.size().height/2;

     std::vector<cv::Vec3b> vec; /*retrieve the values of all the pixels inside the kernel window and stores them in a vector*/
        for (int i = y-kernel_size/2; i <= y+kernel_size/2 && i < image.size().height; i++)
        {
            for (int j = x-kernel_size/2; j <= x+kernel_size/2 && j < image.size().width; j++)
            {
                if(i < 0 || j < 0){
                    continue;
                }else{
                    vec.push_back(image.at<cv::Vec3b>(i,j));
                }
            }
            
        }
        

        /*evaluates average value for h,s,v channels*/
        uint32_t h = 0;
        uint32_t s = 0;
        uint32_t v = 0;
        uchar k = 0;
        for (k; k < vec.size(); k++)
        {
            h = h + (uint32_t)(vec[k].val[0]);
            s = s + (uint32_t)(vec[k].val[1]);
            v = v + (uint32_t)(vec[k].val[2]); 
        }
    cv::Vec3b mean_color(h/k,s/k,v/k); /*stores the average value of the 3 channels in a vector*/
    return mean_color;

}


std::vector<Ball> BallDetector::findBalls(const cv::Mat only_table_image, const cv::Mat field_contour, std::vector<cv::Point> boundaries_contours_poly, std::vector<cv::Point2i> sorted_corners){

        
        std::vector<cv::Mat> channels_masked_table;
        cv::split(only_table_image,channels_masked_table); /*splits the image into the 3 individual channels H,S,V*/

        std::vector<cv::Vec3f> circles;
        //find the circles around the balls --> parameters of hough_circles found after some manual testing to find a trade-off between all initial frames of the 10 clips
        /*uses only the S channel of the image*/
        HoughCircles(channels_masked_table[1], circles, cv::HOUGH_GRADIENT, 1.2, channels_masked_table[1].rows/27, 160, 14.5, 6, 13);

        cv::Vec3b mean_color2 = fieldMeanColor(only_table_image,11);

        /*values to define upper and lower thresholds on the HSV channels for later removal of false positive circles*/
        /*values have been fixed after performing some tests on the first frame of each of the 10 video clips and averaging the obtained results*/
        uchar h_thr = 10;
        uchar s_thr = 255;  
        uchar v_thr = 125;
        uchar h_l,s_l,v_l,h_h,s_h,v_h;

        h_l = (mean_color2[0]-h_thr < 0) ? 0 : mean_color2[0]-h_thr;
        h_h = (mean_color2[0]+h_thr > 179) ? 179 : mean_color2[0]+h_thr;

        s_l = (mean_color2[1]-s_thr < 0) ? 0 : mean_color2[1]-s_thr;
        s_h = (mean_color2[1]+s_thr > 255) ? 255 : mean_color2[1]+s_thr;

        v_l = (mean_color2[2]-v_thr < 0) ? 0 : mean_color2[2]-v_thr;
        v_h = (mean_color2[2]+v_thr > 255) ? 255 : mean_color2[2]+v_thr;

        /*draws circles detected earlier with HoughCircles function only if the satisfy some constraints*/
        for( size_t i = 0; i < circles.size(); i++ ){
            cv::Vec3i c = circles[i];
            cv::Point center = cv::Point(c[0], c[1]);
            int radius = c[2];

            /*checks if the center of the circle is located inside the playing field and the color of the pixel corresponding to the center of the circle is not similar to the one of the field within a given range*/
            if(field_contour.at<uchar>(c[1],c[0]) == 255){
                if(channels_masked_table[0].at<uchar>(c[1],c[0]) < h_h && channels_masked_table[0].at<uchar>(c[1],c[0]) > h_l){
                    if(channels_masked_table[1].at<uchar>(c[1],c[0]) < s_h && channels_masked_table[1].at<uchar>(c[1],c[0]) > s_l){
                        if(channels_masked_table[2].at<uchar>(c[1],c[0]) < v_h && channels_masked_table[2].at<uchar>(c[1],c[0]) > v_l){
                            circles.erase(circles.begin()+i); /*erase the circle from the vector containing them if it does not satisfy the constraints to be considered a real circle corresponding to a ball*/
                            i--;
                            continue;
                        }   
                    }
                }
                
                /*erases all the circles with a distance less than min_dist from the polygon that defines the field boundaries*/
                /*it erases most of the false positive cirlces that are located on the railings of the playing field*/
                double min_dist = 8.2;
                if (cv::pointPolygonTest(boundaries_contours_poly,center,true) < min_dist){
                    circles.erase(circles.begin()+i);
                    i--;
                    continue;
                }

                /*tries to remove all the false positive circles that can be generated by the pot holes of the field by looking at the distance of the center of the circle from the corners of the field*/
                bool remove = false; //to try to remove outliers circles found at field corners holes
                double min_distance_from_corner = 31.0;
                for (int j = 0; j < sorted_corners.size(); j++){
                   if (sqrt(pow(sorted_corners[j].x-center.x,2)+pow(sorted_corners[j].y-center.y,2)) < min_distance_from_corner){
                        remove = true;
                    } 
                }
                
                if(remove){
                    circles.erase(circles.begin()+i);
                    i--;
                    continue;
                }
                

            /*removes all the circles that falls outside the playing field*/    
            }else{
                circles.erase(circles.begin()+i);
                i--;
                continue;
            }
        }

    /*creates the final vector containing all the balls, initialized with only the center and the radius of the circle that identifies the single ball*/
    std::vector<Ball> balls;
    for (int h = 0; h < circles.size(); h++){
        balls.push_back(Ball(circles[h]));
    }
    

    return balls;
}

std::vector<Ball> BallDetector::detectBalls(const cv::Mat &image, const cv::Mat &tableMask, const std::vector<cv::Point> &tableContours, std::vector<cv::Point2i> tableCorners){
    
    cv::Mat hsvImage; 
    cv::cvtColor(image,hsvImage,cv::COLOR_BGR2HSV);

    //removes everything from the initial image apart from the pixels defined by the mask that segments the field
    for (int i = 0; i < image.size().height; i++){
        for (int j = 0; j < image.size().width; j++){
            if( (tableMask.at<uchar>(i,j)) == 0){
                hsvImage.at<cv::Vec3b>(i,j) = cv::Vec3b(0,0,0);
            }
        }
    }

    std::vector<Ball> balls = findBalls(image, tableMask, tableContours, tableCorners);

    return std::vector<Ball>();
}

cv::Mat drawBallsOnFieldMask(const cv::Mat field_mask, std::vector<Ball> balls){

        /*draws each individual ball of the balls vector on the image that contains the mask of the field only without the balls*/
        cv::Mat field_mask_and_balls = field_mask.clone();
        for (int i = 0; i < balls.size(); i++){
            cv::circle(field_mask_and_balls, cv::Point2i(static_cast<int>(balls[i].getBallPosition()[0]), static_cast<int>(balls[i].getBallPosition()[1])), static_cast<int>(balls[i].getBallPosition()[2]), 127, cv::FILLED, cv::LINE_AA);
        }

    return field_mask_and_balls;
}